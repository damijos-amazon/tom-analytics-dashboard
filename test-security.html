<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Implementation Test - TOM Analytics</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #232f3e;
            border-bottom: 3px solid #ff9900;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #232f3e;
            margin-top: 30px;
        }
        
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-item {
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #ccc;
            background: #f9f9f9;
        }
        
        .test-item.pass {
            border-left-color: #4caf50;
            background: #f1f8f4;
        }
        
        .test-item.fail {
            border-left-color: #f44336;
            background: #fef1f0;
        }
        
        .test-item.warning {
            border-left-color: #ff9800;
            background: #fff8f0;
        }
        
        .status {
            font-weight: bold;
            margin-right: 10px;
        }
        
        .status.pass { color: #4caf50; }
        .status.fail { color: #f44336; }
        .status.warning { color: #ff9800; }
        
        button {
            background-color: #ff9900;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        
        button:hover {
            background-color: #ec7211;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .code-block {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }
        
        #results {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>ðŸ”’ Security Implementation Test Suite</h1>
    
    <div class="info">
        <strong>Purpose:</strong> This page tests all security measures implemented in the TOM Analytics Dashboard.
        <br><br>
        <strong>Note:</strong> Some tests require a Supabase connection. Configure your Supabase credentials below.
    </div>
    
    <div class="test-section">
        <h2>Configuration</h2>
        <div>
            <label>Supabase URL:</label><br>
            <input type="text" id="supabaseUrl" placeholder="https://your-project.supabase.co" style="width: 400px; padding: 8px; margin: 5px 0;">
        </div>
        <div>
            <label>Supabase Anon Key:</label><br>
            <input type="text" id="supabaseKey" placeholder="your-anon-key" style="width: 400px; padding: 8px; margin: 5px 0;">
        </div>
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>
    
    <div id="results"></div>
    
    <!-- Load dependencies -->
    <script src="js/security-config.js"></script>
    <script src="js/token-manager.js"></script>
    <script src="js/encryption-service.js"></script>
    <script src="js/security-init.js"></script>
    
    <script>
        let testResults = [];
        
        function addTestResult(category, name, passed, message, details = '') {
            testResults.push({ category, name, passed, message, details });
            displayResults();
        }
        
        function displayResults() {
            const resultsDiv = document.getElementById('results');
            
            // Group by category
            const grouped = {};
            testResults.forEach(result => {
                if (!grouped[result.category]) {
                    grouped[result.category] = [];
                }
                grouped[result.category].push(result);
            });
            
            let html = '';
            for (const [category, results] of Object.entries(grouped)) {
                const passCount = results.filter(r => r.passed).length;
                const totalCount = results.length;
                
                html += `
                    <div class="test-section">
                        <h2>${category} (${passCount}/${totalCount} passed)</h2>
                `;
                
                results.forEach(result => {
                    const statusClass = result.passed ? 'pass' : 'fail';
                    const statusText = result.passed ? 'âœ“ PASS' : 'âœ— FAIL';
                    
                    html += `
                        <div class="test-item ${statusClass}">
                            <span class="status ${statusClass}">${statusText}</span>
                            <strong>${result.name}</strong>
                            <div style="margin-top: 5px;">${result.message}</div>
                            ${result.details ? `<div class="code-block">${result.details}</div>` : ''}
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            resultsDiv.innerHTML = html;
        }
        
        function clearResults() {
            testResults = [];
            document.getElementById('results').innerHTML = '';
        }
        
        async function runAllTests() {
            clearResults();
            
            await testSecurityConfig();
            await testEncryptionService();
            await testTokenManager();
            await testSecurityRequirements();
            await testCSPHeaders();
            
            // Summary
            const totalTests = testResults.length;
            const passedTests = testResults.filter(r => r.passed).length;
            const failedTests = totalTests - passedTests;
            
            console.log(`\n=== Test Summary ===`);
            console.log(`Total: ${totalTests}`);
            console.log(`Passed: ${passedTests}`);
            console.log(`Failed: ${failedTests}`);
            console.log(`Success Rate: ${((passedTests/totalTests)*100).toFixed(1)}%`);
        }
        
        async function testSecurityConfig() {
            const category = '1. Security Configuration';
            
            try {
                const securityConfig = new SecurityConfig();
                
                // Test 1: Initialization
                try {
                    securityConfig.initialize();
                    addTestResult(category, 'Initialize Security Config', true, 
                        'Security configuration initialized successfully');
                } catch (error) {
                    addTestResult(category, 'Initialize Security Config', false, 
                        'Failed to initialize', error.message);
                }
                
                // Test 2: HTTPS validation
                const httpsUrl = 'https://example.com/api';
                const httpUrl = 'http://example.com/api';
                const localhostUrl = 'http://localhost:3000/api';
                
                const httpsValid = securityConfig.validateSecureURL(httpsUrl);
                const httpValid = securityConfig.validateSecureURL(httpUrl);
                const localhostValid = securityConfig.validateSecureURL(localhostUrl);
                
                addTestResult(category, 'HTTPS URL Validation', httpsValid, 
                    'HTTPS URLs are correctly validated');
                addTestResult(category, 'HTTP URL Rejection', !httpValid, 
                    'HTTP URLs are correctly rejected');
                addTestResult(category, 'Localhost Exception', localhostValid, 
                    'Localhost URLs are allowed for development');
                
                // Test 3: Input sanitization
                const maliciousInput = '<script>alert("XSS")</script>';
                const sanitized = securityConfig.sanitizeInput(maliciousInput);
                const isSafe = !sanitized.includes('<script>');
                
                addTestResult(category, 'XSS Prevention', isSafe, 
                    'Malicious scripts are sanitized', 
                    `Input: ${maliciousInput}\nOutput: ${sanitized}`);
                
                // Test 4: Cookie configuration
                const cookieConfig = securityConfig.getCookieConfig();
                const hasSecureFlags = cookieConfig.sameSite === 'Strict';
                
                addTestResult(category, 'Secure Cookie Config', hasSecureFlags, 
                    'Cookie configuration includes secure flags',
                    JSON.stringify(cookieConfig, null, 2));
                
                // Test 5: Environment check
                const isSecure = securityConfig.isSecureEnvironment();
                addTestResult(category, 'Secure Environment Check', isSecure, 
                    'Environment security validated');
                
            } catch (error) {
                addTestResult(category, 'Security Config Tests', false, 
                    'Unexpected error in security config tests', error.message);
            }
        }
        
        async function testEncryptionService() {
            const category = '2. Encryption Service';
            
            try {
                const encryptionService = new EncryptionService();
                
                // Test 1: Initialization
                try {
                    await encryptionService.initialize();
                    addTestResult(category, 'Initialize Encryption', true, 
                        'Encryption service initialized successfully');
                } catch (error) {
                    addTestResult(category, 'Initialize Encryption', false, 
                        'Failed to initialize', error.message);
                    return;
                }
                
                // Test 2: Encrypt/Decrypt
                const plaintext = 'Sensitive SSO credentials';
                try {
                    const encrypted = await encryptionService.encrypt(plaintext);
                    const decrypted = await encryptionService.decrypt(encrypted);
                    
                    addTestResult(category, 'Encrypt/Decrypt', decrypted === plaintext, 
                        'Data encrypted and decrypted successfully',
                        `Original: ${plaintext}\nEncrypted: ${encrypted.substring(0, 50)}...\nDecrypted: ${decrypted}`);
                } catch (error) {
                    addTestResult(category, 'Encrypt/Decrypt', false, 
                        'Encryption/decryption failed', error.message);
                }
                
                // Test 3: SSO Config Encryption
                const ssoConfig = {
                    provider: 'azure',
                    clientId: 'test-client-id',
                    clientSecret: 'super-secret-key',
                    apiKey: 'api-key-12345'
                };
                
                try {
                    const encrypted = await encryptionService.encryptSSOConfig(ssoConfig);
                    const decrypted = await encryptionService.decryptSSOConfig(encrypted);
                    
                    const secretsMatch = decrypted.clientSecret === ssoConfig.clientSecret &&
                                        decrypted.apiKey === ssoConfig.apiKey;
                    
                    addTestResult(category, 'SSO Config Encryption', secretsMatch, 
                        'SSO credentials encrypted and decrypted correctly');
                } catch (error) {
                    addTestResult(category, 'SSO Config Encryption', false, 
                        'SSO encryption failed', error.message);
                }
                
                // Test 4: Hash function
                try {
                    const data = 'password123';
                    const hash1 = await encryptionService.hash(data);
                    const hash2 = await encryptionService.hash(data);
                    
                    addTestResult(category, 'Hash Function', hash1 === hash2, 
                        'Hash function produces consistent results',
                        `Hash: ${hash1}`);
                } catch (error) {
                    addTestResult(category, 'Hash Function', false, 
                        'Hash function failed', error.message);
                }
                
                // Test 5: Secure token generation
                try {
                    const token1 = encryptionService.generateSecureToken(32);
                    const token2 = encryptionService.generateSecureToken(32);
                    
                    const isUnique = token1 !== token2;
                    const isCorrectLength = token1.length === 64; // 32 bytes = 64 hex chars
                    
                    addTestResult(category, 'Secure Token Generation', isUnique && isCorrectLength, 
                        'Secure random tokens generated correctly',
                        `Token 1: ${token1}\nToken 2: ${token2}`);
                } catch (error) {
                    addTestResult(category, 'Secure Token Generation', false, 
                        'Token generation failed', error.message);
                }
                
            } catch (error) {
                addTestResult(category, 'Encryption Tests', false, 
                    'Unexpected error in encryption tests', error.message);
            }
        }
        
        async function testTokenManager() {
            const category = '3. Token Management';
            
            // Note: Full token manager tests require Supabase connection
            // These are basic structural tests
            
            try {
                // Test 1: Token format validation
                const validToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
                const invalidToken = 'not-a-valid-token';
                
                // Create a mock token manager for testing
                const mockSupabase = { auth: { signOut: async () => ({}) } };
                const tokenManager = new TokenManager(mockSupabase);
                
                const validResult = tokenManager.validateTokenFormat(validToken);
                const invalidResult = tokenManager.validateTokenFormat(invalidToken);
                
                addTestResult(category, 'Token Format Validation', validResult && !invalidResult, 
                    'Token format validation works correctly');
                
                // Test 2: Token decoding
                try {
                    const decoded = tokenManager.decodeToken(validToken);
                    const hasPayload = decoded && decoded.sub === '1234567890';
                    
                    addTestResult(category, 'Token Decoding', hasPayload, 
                        'JWT tokens decoded correctly',
                        JSON.stringify(decoded, null, 2));
                } catch (error) {
                    addTestResult(category, 'Token Decoding', false, 
                        'Token decoding failed', error.message);
                }
                
                // Test 3: Secure storage methods
                try {
                    tokenManager.setSecureItem('test-key', 'test-value');
                    const retrieved = tokenManager.getSecureItem('test-key');
                    tokenManager.removeSecureItem('test-key');
                    const removed = tokenManager.getSecureItem('test-key');
                    
                    addTestResult(category, 'Secure Storage', 
                        retrieved === 'test-value' && removed === null, 
                        'Secure storage operations work correctly');
                } catch (error) {
                    addTestResult(category, 'Secure Storage', false, 
                        'Storage operations failed', error.message);
                }
                
            } catch (error) {
                addTestResult(category, 'Token Manager Tests', false, 
                    'Unexpected error in token manager tests', error.message);
            }
        }
        
        async function testSecurityRequirements() {
            const category = '4. Security Requirements';
            
            try {
                const requirements = validateSecurityRequirements();
                
                addTestResult(category, 'Web Crypto API', typeof crypto !== 'undefined', 
                    'Web Crypto API is available');
                
                addTestResult(category, 'Session Storage', typeof sessionStorage !== 'undefined', 
                    'Session storage is available');
                
                addTestResult(category, 'Fetch API', typeof fetch !== 'undefined', 
                    'Fetch API is available');
                
                const isSecureProtocol = window.location.protocol === 'https:' || 
                                        window.location.hostname === 'localhost';
                
                addTestResult(category, 'Secure Protocol', isSecureProtocol, 
                    isSecureProtocol ? 'Running on secure protocol' : 'Not using HTTPS',
                    `Protocol: ${window.location.protocol}`);
                
                addTestResult(category, 'All Requirements', requirements, 
                    'All security requirements met');
                
            } catch (error) {
                addTestResult(category, 'Security Requirements', false, 
                    'Failed to validate requirements', error.message);
            }
        }
        
        async function testCSPHeaders() {
            const category = '5. Content Security Policy';
            
            try {
                // Check if CSP meta tag exists
                const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
                
                addTestResult(category, 'CSP Meta Tag', cspMeta !== null, 
                    cspMeta ? 'CSP meta tag is present' : 'CSP meta tag not found',
                    cspMeta ? cspMeta.content : 'N/A');
                
                // Check X-Frame-Options
                const frameMeta = document.querySelector('meta[http-equiv="X-Frame-Options"]');
                
                addTestResult(category, 'X-Frame-Options', frameMeta !== null, 
                    frameMeta ? 'X-Frame-Options header set' : 'X-Frame-Options not found',
                    frameMeta ? frameMeta.content : 'N/A');
                
                // Check X-Content-Type-Options
                const noSniffMeta = document.querySelector('meta[http-equiv="X-Content-Type-Options"]');
                
                addTestResult(category, 'X-Content-Type-Options', noSniffMeta !== null, 
                    noSniffMeta ? 'X-Content-Type-Options header set' : 'X-Content-Type-Options not found',
                    noSniffMeta ? noSniffMeta.content : 'N/A');
                
            } catch (error) {
                addTestResult(category, 'CSP Tests', false, 
                    'Failed to test CSP headers', error.message);
            }
        }
        
        // Auto-run tests on page load
        window.addEventListener('load', () => {
            console.log('Security Test Suite loaded. Click "Run All Tests" to begin.');
        });
    </script>
</body>
</html>
